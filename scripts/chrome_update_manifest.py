#!/usr/bin/python
# Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Script that syncs the repo manifest with .DEPS.git."""


import logging
import multiprocessing
import os
import sys
import StringIO

from chromite.scripts import chrome_set_ver
from chromite.lib import commandline
from chromite.lib import cros_build_lib
from chromite.lib import git
from chromite.lib import osutils
from chromite.buildbot import constants
from chromite.buildbot import repository


_CHROMIUM_ROOT = 'chromium'
_CHROMIUM_SRC_ROOT = os.path.join(_CHROMIUM_ROOT, 'src')
_CHROMIUM_SRC_INTERNAL = os.path.join(_CHROMIUM_ROOT, 'src-internal')

_MANIFEST_TEMPLATE = """\
<?xml version="1.0" encoding="UTF-8"?>
<manifest>
<!-- @@@@ THIS CONTENT IS AUTOGENERATED; DO NOT MODIFY! @@@@ -->

  <include name="%(include_target)s" />
%(content)s
</manifest>
"""

_TYPE_MARKER = """\

<!-- @@@@ THIS IS THE %(type)s CONTENT @@@@ -->

"""

_PROJECT = """\
  <project remote="%(remote)s"
           path="%(path)s"
           name="%(name)s"
           revision="%(ref)s" />
"""


_EXTERNAL_MANIFEST_DIR = 'update-manifest'
_INTERNAL_MANIFEST_DIR = 'update-manifest-internal'
_EXTERNAL_MANIFEST_PROJECT = 'chromiumos/manifest'
_INTERNAL_MANIFEST_PROJECT = 'chromeos/manifest-internal'
_EXTERNAL_TEST_DIR = 'external'
_INTERNAL_TEST_DIR = 'internal'
_EXTERNAL_REMOTE = 'chromium'
_INTERNAL_REMOTE = 'chrome'

_CHROMIUM_SRC_PROJECT = 'chromium/src'
_CHROMIUM_SRC_INTERNAL_PROJECT = 'chrome/src-internal'
TEST_BRANCH = "temp-newly-synced"
MANIFEST_FILE = 'gerrit-source.xml'
INCLUDE_TARGET = 'full.xml'


def _MkProject(path, name, remote, branch='master'):
  return _PROJECT % {'path':path, 'name':name, 'remote':remote,
                     'ref':'refs/heads/%s' % (branch,)}


def ConvertDepsToManifest(deps_file, project_blacklist, manifest_file,
                          remote):
  """Convert dependencies in .DEPS.git files to manifest entries.

  Arguments:
    deps_file: The path to the .DEPS.git file.
    project_blacklist: Set of project names that we shouldn't write
      entries for; specifically since they're already in our parent.
    manifest_file: The file object to write manifest entries to.
    remote: The remote value to write to the new manifest.
  """
  _, merged_deps = chrome_set_ver.GetParsedDeps(deps_file)
  mappings = chrome_set_ver.GetPathToProjectMappings(merged_deps)

  # Check for double checkouts and blacklisted projects.
  previous_projects = set(project_blacklist)
  for rel_path, project in sorted(mappings.iteritems(), key=lambda x: x[1]):
    rel_path = os.path.join('chromium', rel_path)
    if project.startswith('chromiumos'):
      cros_build_lib.Warning('Skipping project %s in %s', project, deps_file)
    elif project in previous_projects:
      cros_build_lib.Warning('Found double checkout of %s to %s',
                             project, rel_path)
    else:
      manifest_file.write(_MkProject(rel_path, project, remote))
      previous_projects.add(project)


class Manifest(object):
  """Encapsulates manifest update logic for an external or internal manifest."""
  def __init__(self, repo_root, manifest_path, internal, dryrun=True,
               reference=None):
    self.repo_root = repo_root
    self.manifest_path = manifest_path
    self.manifest_dir = os.path.dirname(manifest_path)
    self.internal = internal
    self.dryrun = dryrun
    self.reference = reference

  def CreateNewManifest(self):
    """Generates a new manifest with updated Chrome entries."""
    # Prepare git repo for push
    git.CreatePushBranch(
        TEST_BRANCH, self.manifest_dir,
        remote_push_branch=('origin', 'refs/heads/master'))

    content = StringIO.StringIO()
    content.write(_TYPE_MARKER % {'type': 'EXTERNAL'})
    content.write(_MkProject('chromium/src', 'chromium/src',
                             _EXTERNAL_REMOTE, branch='git-svn'))
    # Grab the repo manifest, and ensure that we're not adding a project that
    # our inherit target already has.
    include_target = os.path.join(self.manifest_dir, INCLUDE_TARGET)
    existing_projects = frozenset(git.Manifest.Cached(
        include_target, manifest_include_dir=self.manifest_dir).projects)
    ConvertDepsToManifest(
        os.path.join(self.repo_root, _CHROMIUM_SRC_ROOT, '.DEPS.git'),
        existing_projects, content, _EXTERNAL_REMOTE)

    if self.internal:
      content.write(_TYPE_MARKER % {'type': 'INTERNAL'})
      content.write(_MkProject('chromium/src-internal', 'chrome/src-internal',
                               'cros-internal'))
      ConvertDepsToManifest(
          os.path.join(self.repo_root, _CHROMIUM_SRC_INTERNAL, '.DEPS.git'),
          existing_projects, content, _INTERNAL_REMOTE)

    osutils.WriteFile(
        self.manifest_path,
        _MANIFEST_TEMPLATE % {'content':content.getvalue(),
                              'include_target':INCLUDE_TARGET})

  def IsNewManifestDifferent(self):
    """Checks if newly generated manifest is different from old manifest."""
    return bool(
        git.RunGit(self.manifest_dir, ['status', '--porcelain']).output.strip())

  def CommitNewManifest(self):
    git.RunGit(self.manifest_dir, ['add', self.manifest_path])
    git.RunGit(self.manifest_dir, [
        'commit', '-m',
        'Auto-updating manifest to match .DEPS.git file'])

  def TestNewManifest(self, testroot):
    """Runs a 'repo sync' off of new manifest to verify things aren't broken."""
    # Copy to .repo/manifest.xml and run repo sync
    test_dir = os.path.join(
        testroot,
        _INTERNAL_TEST_DIR if self.internal else _EXTERNAL_TEST_DIR)

    osutils.SafeMakedirs(test_dir)

    # Do as cheap a sync as possible; network only is good enough,
    # allow shallow cloning if we don't have a reference, and sync
    # strictly the target branch.
    repo = repository.RepoRepository(
        self.manifest_dir, test_dir, branch=TEST_BRANCH,
        referenced_repo=self.reference)
    try:
      repo.Sync(jobs=multiprocessing.cpu_count() + 1, network_only=True)
    except Exception:
      cros_build_lib.Error('Failed to sync with new manifest!')
      raise

  def PushChanges(self):
    """Push changes to manifest live."""
    git.PushWithRetry(
        TEST_BRANCH, self.manifest_dir, dryrun=self.dryrun)

  def PerformUpdate(self, testroot):
    self.CreateNewManifest()
    if not self.IsNewManifestDifferent():
      return
    self.CommitNewManifest()
    self.TestNewManifest(testroot)
    self.PushChanges()


def main(argv=None):
  if argv is None:
    argv = sys.argv[1:]

  usage = 'usage: %prog'
  parser = commandline.OptionParser(usage=usage)

  parser.add_option('-r', '--testroot', action='store', type='path',
                    help=('Directory where test checkout is stored.'))
  parser.add_option('-f', '--force', default=False, action='store_true',
                    help='Actually push manifest changes.')
  parser.add_option('--save-dir', default=None, action='store', type='path',
                    help='The location to save the updated external and '
                    'internal manifest repositories to for a successful run.  '
                    'Primarily for debugging.')
  parser.add_option(
      '--internal-manifest-url',
      default='%s/%s' % (constants.GERRIT_INT_SSH_URL,
                         _INTERNAL_MANIFEST_PROJECT),
      help='Url to fetch the internal manifest from.')
  parser.add_option(
      '--external-manifest-url',
      default='%s/%s' % (constants.GERRIT_SSH_URL,
                         _EXTERNAL_MANIFEST_PROJECT),
      help='Url to fetch the external manifest from.')
  parser.add_option('-v', '--verbose', default=False, action='store_true',
                    help='Run with debug output.')
  parser.add_option('--reference', default=None,
                    help="Repository to reference")
  (options, _inputs) = parser.parse_args(argv)

  if not options.testroot:
    parser.error('Please specify a test root!')

  # Set cros_build_lib debug level to hide RunCommand spew.
  logging.getLogger().setLevel(
      logging.DEBUG if options.verbose else logging.WARN)

  repo_root = git.FindRepoCheckoutRoot(os.getcwd())
  chromium_src_root = os.path.join(repo_root, _CHROMIUM_SRC_ROOT)
  if not os.path.isdir(chromium_src_root):
    parser.error('chromium src/ dir not found')

  if options.reference is None:
    options.reference = repo_root

  project_list = (_CHROMIUM_SRC_PROJECT, _CHROMIUM_SRC_INTERNAL_PROJECT)
  manifest = git.ManifestCheckout.Cached(repo_root)
  missing = set(project_list).difference(manifest.projects)
  if missing:
    parser.error(
        "Required project(s) weren't found; are you on a %r checkout?:\n\t%s"
        % (MANIFEST_FILE, '\n\t'.join(sorted(missing))))

  with osutils.TempDirContextManager() as working_dir:
    external_manifest_dir = os.path.join(working_dir, _EXTERNAL_MANIFEST_DIR)
    internal_manifest_dir = os.path.join(working_dir, _INTERNAL_MANIFEST_DIR)

    # Sync manifest and .DEPS.git files.
    repository.CloneGitRepo(
        external_manifest_dir, options.internal_manifest_url)
    repository.CloneGitRepo(
        internal_manifest_dir, options.internal_manifest_url)

    cros_build_lib.RunCommand(
        ['repo', 'sync', '-cd', '-j%i' % len(project_list)] + project_list,
        cwd=repo_root)

    # Update external manifest.
    external_manifest = os.path.join(external_manifest_dir, MANIFEST_FILE)
    Manifest(repo_root, external_manifest, internal=False,
             reference=options.reference,
             dryrun=not options.force).PerformUpdate(options.testroot)

    # Update internal manifest.
    internal_manifest = os.path.join(internal_manifest_dir, MANIFEST_FILE)
    Manifest(repo_root, internal_manifest, internal=True,
             reference=options.reference,
             dryrun=not options.force).PerformUpdate(options.testroot)

    if not options.force:
      # Since we wipe the tmp space, output the generated manifests so
      # they can be examined.
      print "external manifest is now:"
      print osutils.ReadFile(external_manifest)
      print
      print "internal manifest is now:"
      print osutils.ReadFile(internal_manifest)

    if options.save_dir:
      osutils.SafeMakedirs(options.save_dir)
      cros_build_lib.RunCommand(
          ['mv', external_manifest_dir, internal_manifest_dir,
           options.save_dir])
